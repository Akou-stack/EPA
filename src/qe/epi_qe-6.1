diff -ur qe-6.1_original/PHonon/PH/check_initial_status.f90 qe-6.1/PHonon/PH/check_initial_status.f90
--- qe-6.1_original/PHonon/PH/check_initial_status.f90	2017-03-02 22:46:26.000000000 -0800
+++ qe-6.1/PHonon/PH/check_initial_status.f90	2017-04-19 08:57:14.603510522 -0700
@@ -72,7 +72,7 @@
   USE io_files,        ONLY : tmp_dir
   USE lsda_mod,        ONLY : nspin
   USE scf,             ONLY : rho
-  USE disp,            ONLY : nqs, x_q, comp_iq, nq1, nq2, nq3, &
+  USE disp,            ONLY : nqs, x_q, wq, comp_iq, nq1, nq2, nq3, &
                               done_iq, lgamma_iq
   USE qpoint,          ONLY : xq
   USE control_lr,      ONLY : lgamma
@@ -138,8 +138,10 @@
         nqs = 1
         last_q = 1
         ALLOCATE(x_q(3,1))
+        ALLOCATE(wq(1))
         ALLOCATE(lgamma_iq(1))
         x_q(:,1)=xq(:)
+        wq(1)=1.0d0
         lgamma_iq(1)=lgamma
         !
      END IF
diff -ur qe-6.1_original/PHonon/PH/do_phonon.f90 qe-6.1/PHonon/PH/do_phonon.f90
--- qe-6.1_original/PHonon/PH/do_phonon.f90	2017-03-02 22:46:26.000000000 -0800
+++ qe-6.1/PHonon/PH/do_phonon.f90	2017-04-19 08:57:14.604658000 -0700
@@ -33,7 +33,7 @@
   USE disp,            ONLY : nqs
   USE control_ph,      ONLY : epsil, trans, qplot, only_init, &
                               only_wfc, rec_code, where_rec
-  USE el_phon,         ONLY : elph, elph_mat, elph_simple
+  USE el_phon,         ONLY : elph, elph_mat, elph_simple, elph_epi
   !
   ! YAMBO >
   USE YAMBO,           ONLY : elph_yambo
@@ -116,6 +116,8 @@
            CALL elphsum_wannier(iq)
         ELSEIF( elph_simple ) THEN
            CALL elphsum_simple()
+        ELSEIF( elph_epi ) THEN
+           CALL elphfil_epi(iq)
         ELSEIF( elph_yambo ) THEN
            CALL elph_yambo_eval_and_IO()
         ELSEIF(elph_tetra == 1) THEN
Only in qe-6.1/PHonon/PH: do_phonon.f90.orig
diff -ur qe-6.1_original/PHonon/PH/elph.f90 qe-6.1/PHonon/PH/elph.f90
--- qe-6.1_original/PHonon/PH/elph.f90	2017-03-02 22:46:26.000000000 -0800
+++ qe-6.1/PHonon/PH/elph.f90	2017-04-19 08:57:14.605610000 -0700
@@ -12,7 +12,7 @@
   !
   SAVE
   !
-  LOGICAL :: elph, elph_mat, elph_simple
+  LOGICAL :: elph, elph_mat, elph_simple, elph_epi
   INTEGER :: elph_nbnd_min, elph_nbnd_max
   INTEGER :: el_ph_ngauss, el_ph_nsigma
   INTEGER :: iunwfcwann, lrwfcr
diff -ur qe-6.1_original/PHonon/PH/elphon.f90 qe-6.1/PHonon/PH/elphon.f90
--- qe-6.1_original/PHonon/PH/elphon.f90	2017-03-02 22:46:26.000000000 -0800
+++ qe-6.1/PHonon/PH/elphon.f90	2017-04-19 08:57:14.606958163 -0700
@@ -1136,6 +1136,313 @@
 END SUBROUTINE elphsum_simple
    
 !-----------------------------------------------------------------------
+SUBROUTINE elphfil_epi(iq)
+  !-----------------------------------------------------------------------
+  !
+  !      EPI method
+  !      Writes electron-phonon coupling matrix elements to file
+  !      Written by Georgy Samsonidze on 2015-01-28
+  !
+  !      TODO: G-vectors (gvect/mill), k+G-indices (iunigk/igk),
+  !            NC-US-PAW wavefunctions (wavefunctions_module/evc),
+  !            k+q+G-indices (qpoint/igkq)
+  !
+  !-----------------------------------------------------------------------
+  USE cell_base, ONLY : ibrav, alat, omega, tpiba, at, bg
+  USE disp, ONLY : nq1, nq2, nq3, nqs, x_q, wq, lgamma_iq
+  USE dynmat, ONLY : dyn, w2
+  USE el_phon, ONLY : el_ph_mat, done_elph
+  USE fft_base, ONLY : dfftp, dffts, dfftb
+  USE gvect, ONLY : ngm_g, ecutrho
+  USE io_global, ONLY : ionode, ionode_id
+  USE ions_base, ONLY : nat, nsp, atm, ityp, tau
+  USE kinds, ONLY : DP
+  USE klist, ONLY : xk, wk, nelec, nks, nkstot, ngk
+  USE lsda_mod, ONLY : nspin, isk
+  USE modes, ONLY : nirr, nmodes, npert, npertx, u, t, tmq, &
+       name_rap_mode, num_rap_mode
+  USE lr_symm_base, ONLY : irgq, nsymq, irotmq, rtau, gi, gimq, &
+       minus_q, invsymq
+  USE mp, ONLY : mp_bcast, mp_sum
+  USE mp_images, ONLY : intra_image_comm
+  USE mp_pools, ONLY : npool, intra_pool_comm
+  USE qpoint, ONLY : nksq, nksqtot, ikks, ikqs, eigqts
+  USE start_k, ONLY : nk1, nk2, nk3, k1, k2, k3
+  USE symm_base, ONLY : s, invs, ftau, nrot, nsym, nsym_ns, &
+       nsym_na, ft, sr, sname, t_rev, irt, time_reversal, &
+       invsym, nofrac, allfrac, nosym, nosym_evc, no_t_rev
+  USE wvfct, ONLY : nbnd, et, wg
+  USE gvecw, ONLY : ecutwfc
+
+  IMPLICIT NONE
+
+  INTEGER, INTENT(IN) :: iq
+
+  CHARACTER(LEN=80), PARAMETER :: filelph = 'epi_espresso.dat'
+
+  INTEGER :: iuelph, ios, irr, ii, jj, kk, ll
+  character :: cdate*9, ctime*9, sdate*32, stime*32, &
+       stitle*32, myaccess*10, mystatus*7
+
+  REAL(DP), ALLOCATABLE :: xk_collect(:,:), wk_collect(:)
+  REAL(DP), ALLOCATABLE :: et_collect(:,:), wg_collect(:,:)
+  INTEGER, ALLOCATABLE :: ngk_merge(:), ngk_collect(:)
+  INTEGER, ALLOCATABLE :: ikks_collect(:), ikqs_collect(:)
+  COMPLEX(DP), ALLOCATABLE :: el_ph_mat_collect(:,:,:,:)
+
+  INTEGER, EXTERNAL :: find_free_unit, atomic_number
+
+  DO irr = 1, nirr
+     IF (.NOT. done_elph(irr)) RETURN
+  ENDDO
+
+  IF (iq .EQ. 1) THEN
+     myaccess = 'sequential'
+     mystatus = 'replace'
+  ELSE
+     myaccess = 'append'
+     mystatus = 'old'
+  ENDIF
+  IF (ionode) THEN
+     iuelph = find_free_unit()
+     OPEN(unit = iuelph, file = TRIM(filelph), form = 'unformatted', &
+          access = myaccess, status = mystatus, iostat = ios)
+  ELSE
+     iuelph = 0
+  ENDIF
+  CALL mp_bcast(ios, ionode_id, intra_image_comm)
+  CALL errore('elphfil_epi', 'opening file ' // filelph, ABS(ios))
+
+  IF (iq .EQ. 1) THEN
+     CALL date_and_tim(cdate, ctime)
+     WRITE(sdate, '(A2,"-",A3,"-",A4,21X)') cdate(1:2), cdate(3:5), cdate(6:9)
+     WRITE(stime, '(A8,24X)') ctime(1:8)
+     WRITE(stitle, '("EPI-Complex",21X)')
+     CALL cryst_to_cart(nqs, x_q, at, -1)
+     ! write header
+     IF (ionode) THEN
+        WRITE(iuelph) stitle, sdate, stime
+        WRITE(iuelph) ibrav, nat, nsp, nrot, nsym, nsym_ns, nsym_na, &
+             ngm_g, nspin, nbnd, nmodes, nqs
+        WRITE(iuelph) nq1, nq2, nq3, nk1, nk2, nk3, k1, k2, k3
+        WRITE(iuelph) time_reversal, invsym, nofrac, allfrac, nosym, &
+             nosym_evc, no_t_rev
+        WRITE(iuelph) alat, omega, tpiba, nelec, ecutrho, ecutwfc
+        WRITE(iuelph) dfftp%nr1, dfftp%nr2, dfftp%nr3
+        WRITE(iuelph) dffts%nr1, dffts%nr2, dffts%nr3
+        WRITE(iuelph) dfftb%nr1, dfftb%nr2, dfftb%nr3
+        WRITE(iuelph) ((at(ii, jj), ii = 1, 3), jj = 1, 3)
+        WRITE(iuelph) ((bg(ii, jj), ii = 1, 3), jj = 1, 3)
+        WRITE(iuelph) (atomic_number(atm(ii)), ii = 1, nsp)
+        WRITE(iuelph) (ityp(ii), ii = 1, nat)
+        WRITE(iuelph) ((tau(ii, jj), ii = 1, 3), jj = 1, nat)
+        WRITE(iuelph) ((x_q(ii, jj), ii = 1, 3), jj = 1, nqs)
+        WRITE(iuelph) (wq(ii), ii = 1, nqs)
+        WRITE(iuelph) (lgamma_iq(ii), ii = 1, nqs)
+     ENDIF
+     CALL cryst_to_cart(nqs, x_q, bg, 1)
+  ENDIF
+
+  ! collect data for current q-point
+  ALLOCATE(xk_collect(3, nkstot))
+  ALLOCATE(wk_collect(nkstot))
+  ALLOCATE(et_collect(nbnd, nkstot))
+  ALLOCATE(wg_collect(nbnd, nkstot))
+  ALLOCATE(ngk_merge(nks))
+  ALLOCATE(ngk_collect(nkstot))
+  ALLOCATE(ikks_collect(nksqtot))
+  ALLOCATE(ikqs_collect(nksqtot))
+  ALLOCATE(el_ph_mat_collect(nbnd, nbnd, nksqtot, nmodes))
+  ngk_merge = ngk
+  CALL mp_sum(ngk_merge, intra_pool_comm)
+  IF (npool > 1) THEN
+     CALL poolcollect(3, nks, xk, nkstot, xk_collect)
+     ! wk(nks) and wk_collect(nkstot) are declared as
+     ! wk(1, nks) and wk_collect(1, nkstot) inside poolcollect
+     CALL poolcollect(1, nks, wk, nkstot, wk_collect)
+     CALL poolcollect(nbnd, nks, et, nkstot, et_collect)
+     CALL poolcollect(nbnd, nks, wg, nkstot, wg_collect)
+     CALL ngk_all(ngk_collect, ngk_merge, nkstot, nks)
+     CALL ikks_ikqs_all(ikks, ikqs, ikks_collect, ikqs_collect, &
+          nksqtot, nksq)
+     CALL el_ph_collect(nmodes, el_ph_mat, el_ph_mat_collect, nksqtot, nksq)
+  ELSE
+     xk_collect(1:3, 1:nks) = xk(1:3, 1:nks)
+     wk_collect(1:nks) = wk(1:nks)
+     et_collect(1:nbnd, 1:nks) = et(1:nbnd, 1:nks)
+     wg_collect(1:nbnd, 1:nks) = wg(1:nbnd, 1:nks)
+     ngk_collect(1:nks) = ngk_merge(1:nks)
+     ikks_collect(1:nksq) = ikks(1:nksq)
+     ikqs_collect(1:nksq) = ikqs(1:nksq)
+     el_ph_mat_collect(1:nbnd, 1:nbnd, 1:nksq, 1:nmodes) = &
+          el_ph_mat(1:nbnd, 1:nbnd, 1:nksq, 1:nmodes)
+  ENDIF
+  CALL cryst_to_cart(nkstot, xk_collect, at, -1)
+  ! write data for current q-point
+  IF (ionode) THEN
+     WRITE(iuelph) nsymq, irotmq, nirr, npertx, nkstot, nksqtot
+     WRITE(iuelph) minus_q, invsymq
+     WRITE(iuelph) (irgq(ii), ii = 1, 48)
+     WRITE(iuelph) (npert(ii), ii = 1, nmodes)
+     WRITE(iuelph) (((rtau(ii, jj, kk), ii = 1, 3), jj = 1, 48), &
+          kk = 1, nat)
+     WRITE(iuelph) ((gi(ii, jj), ii = 1, 3), jj = 1, 48)
+     WRITE(iuelph) (gimq(ii), ii = 1, 3)
+     WRITE(iuelph) ((u(ii, jj), ii = 1, nmodes), jj = 1, nmodes)
+     WRITE(iuelph) ((((t(ii, jj, kk, ll), ii = 1, npertx), &
+          jj = 1, npertx), kk = 1, 48), ll = 1, nmodes)
+     WRITE(iuelph) (((tmq(ii, jj, kk), ii = 1, npertx), &
+          jj = 1, npertx), kk = 1, nmodes)
+     WRITE(iuelph) (name_rap_mode(ii), ii = 1, nmodes)
+     WRITE(iuelph) (num_rap_mode(ii), ii = 1, nmodes)
+     WRITE(iuelph) (((s(ii, jj, kk), ii = 1, 3), jj = 1, 3), kk = 1, 48)
+     WRITE(iuelph) (invs(ii), ii = 1, 48)
+     WRITE(iuelph) ((ftau(ii, jj), ii = 1, 3), jj = 1, 48)
+     WRITE(iuelph) ((ft(ii, jj), ii = 1, 3), jj = 1, 48)
+     WRITE(iuelph) (((sr(ii, jj, kk), ii = 1, 3), jj = 1, 3), kk = 1, 48)
+     WRITE(iuelph) (sname(ii), ii = 1, 48)
+     WRITE(iuelph) (t_rev(ii), ii = 1, 48)
+     WRITE(iuelph) ((irt(ii, jj), ii = 1, 48), jj = 1, nat)
+     WRITE(iuelph) ((xk_collect(ii, jj), ii = 1, 3), jj = 1, nkstot)
+     WRITE(iuelph) (wk_collect(ii), ii = 1, nkstot)
+     WRITE(iuelph) ((et_collect(ii, jj), ii = 1, nbnd), jj = 1, nkstot)
+     WRITE(iuelph) ((wg_collect(ii, jj), ii = 1, nbnd), jj = 1, nkstot)
+     WRITE(iuelph) (isk(ii), ii = 1, nkstot)
+     WRITE(iuelph) (ngk_collect(ii), ii = 1, nkstot)
+     WRITE(iuelph) (ikks_collect(ii), ii = 1, nksqtot)
+     WRITE(iuelph) (ikqs_collect(ii), ii = 1, nksqtot)
+     WRITE(iuelph) (eigqts(ii), ii = 1, nat)
+     WRITE(iuelph) (w2(ii), ii = 1, nmodes)
+     WRITE(iuelph) ((dyn(ii, jj), ii = 1, nmodes), jj = 1, nmodes)
+     WRITE(iuelph) ((((el_ph_mat_collect(ii, jj, kk, ll), ii = 1, nbnd), &
+          jj = 1, nbnd), kk = 1, nksqtot), ll = 1, nmodes)
+     CLOSE (unit = iuelph, status = 'keep')
+  ENDIF
+  CALL cryst_to_cart(nkstot, xk_collect, bg, 1)
+  DEALLOCATE(xk_collect)
+  DEALLOCATE(wk_collect)
+  DEALLOCATE(et_collect)
+  DEALLOCATE(wg_collect)
+  DEALLOCATE(ngk_merge)
+  DEALLOCATE(ngk_collect)
+  DEALLOCATE(ikks_collect)
+  DEALLOCATE(ikqs_collect)
+  DEALLOCATE(el_ph_mat_collect)
+
+  RETURN
+
+END SUBROUTINE elphfil_epi
+   
+SUBROUTINE ngk_all( ngk_collect, ngk_merge, nkstot, nks )
+  !----------------------------------------------------------------------------
+  !
+  ! ... This routine collects numbers of G-vectors for all k-points 
+  ! ... (with granularity kunit) among nodes and sets the variable 
+  ! ... ngk_collect
+  !
+  USE mp_pools,  ONLY : my_pool_id, npool, kunit, inter_pool_comm
+  USE mp,        ONLY : mp_sum
+  !
+  IMPLICIT NONE
+  !
+  INTEGER :: nkstot, nks
+    ! total number of k-points
+    ! number of k-points per pool
+  INTEGER :: ngk_merge(nks)
+  INTEGER :: ngk_collect(nkstot)
+    ! number of G-vectors for each k-point
+  !
+#if defined (__MPI)
+  !
+  INTEGER :: nbase, rest, nks1
+  !
+  ngk_collect=0
+  !
+  nks1    = kunit * ( nkstot / kunit / npool )
+  !
+  rest = ( nkstot - nks1 * npool ) / kunit
+  !
+  IF ( ( my_pool_id + 1 ) <= rest ) nks1 = nks1 + kunit
+  !
+  IF (nks1.ne.nks) &
+     call errore('ngk_all','problems with nks1',1)
+  !
+  ! ... calculates nbase = the position in the list of the first point that
+  ! ...                    belong to this npool - 1
+  !
+  nbase = nks * my_pool_id
+  !
+  IF ( ( my_pool_id + 1 ) > rest ) nbase = nbase + rest * kunit
+  !
+  ! copy the original points in the correct position of the list
+  !
+  ngk_collect(nbase+1:nbase+nks) = ngk_merge(1:nks)
+  !
+  CALL mp_sum( ngk_collect, inter_pool_comm )
+  !
+#endif
+  !
+  RETURN
+  !
+END SUBROUTINE ngk_all
+   
+SUBROUTINE ikks_ikqs_all( ikks, ikqs, ikks_collect, ikqs_collect, &
+     nksqtot, nksq )
+  !----------------------------------------------------------------------------
+  !
+  ! ... This routine adjusts and collects the indices of k- and k+q-points.
+  !
+  USE mp_pools, ONLY : my_pool_id, npool, kunit, inter_pool_comm
+  USE mp,        ONLY : mp_sum
+  !
+  IMPLICIT NONE
+  !
+  INTEGER :: nksqtot, nksq
+    ! total number of k-points
+    ! number of k-points per pool
+  INTEGER :: ikks(nksq), ikqs(nksq)
+  INTEGER :: ikks_collect(nksqtot), ikqs_collect(nksqtot)
+    ! indices of k and k+q points
+    ! collected indices of k and k+q points
+  !
+#if defined (__MPI)
+  !
+  INTEGER :: nbase, rest, nks1
+  !
+  ikks_collect=0
+  ikqs_collect=0
+  !
+  nks1    = ( nksqtot / npool )
+  !
+  rest = ( nksqtot - nks1 * npool ) 
+  !
+  IF ( ( my_pool_id + 1 ) <= rest ) nks1 = nks1 + 1
+  !
+  IF (nks1.ne.nksq) &
+     call errore('ikks_ikqs_all','problems with nks1',1)
+  !
+  ! ... calculates nbase = the position in the list of the first point that
+  ! ...                    belong to this npool - 1
+  !
+  nbase = nksq * my_pool_id
+  !
+  IF ( ( my_pool_id + 1 ) > rest ) nbase = nbase + rest 
+  !
+  ! copy the original points in the correct position of the list
+  !
+  ikks_collect(nbase+1:nbase+nksq) = ikks(1:nksq) + nbase * kunit
+  ikqs_collect(nbase+1:nbase+nksq) = ikqs(1:nksq) + nbase * kunit
+  !
+  CALL mp_sum( ikks_collect, inter_pool_comm )
+  CALL mp_sum( ikqs_collect, inter_pool_comm )
+  !
+#endif
+  !
+  RETURN
+  !
+END SUBROUTINE ikks_ikqs_all
+   
+!-----------------------------------------------------------------------
 FUNCTION dos_ef (ngauss, degauss, ef, et, wk, nks, nbnd)
   !-----------------------------------------------------------------------
   !
Only in qe-6.1/PHonon/PH: elphon.f90.orig
diff -ur qe-6.1_original/PHonon/PH/phq_readin.f90 qe-6.1/PHonon/PH/phq_readin.f90
--- qe-6.1_original/PHonon/PH/phq_readin.f90	2017-03-02 22:46:26.000000000 -0800
+++ qe-6.1/PHonon/PH/phq_readin.f90	2017-04-19 08:57:14.608212985 -0700
@@ -67,7 +67,7 @@
   USE cryst_ph,      ONLY : magnetic_sym
   USE ph_restart,    ONLY : ph_readfile
   USE xml_io_base,   ONLY : create_directory
-  USE el_phon,       ONLY : elph,elph_mat,elph_simple,elph_nbnd_min, elph_nbnd_max, &
+  USE el_phon,       ONLY : elph,elph_mat,elph_simple,elph_epi,elph_nbnd_min, elph_nbnd_max, &
                             el_ph_sigma, el_ph_nsigma, el_ph_ngauss,auxdvscf
   USE dfile_star,    ONLY : drho_star, dvscf_star
 
@@ -376,20 +376,29 @@
      elph=.true.
      elph_mat=.false.
      elph_simple=.true. 
+     elph_epi=.false.
+  CASE( 'epi' )
+     elph=.true.
+     elph_mat=.false.
+     elph_simple=.false.
+     elph_epi=.true.
   CASE( 'Wannier' )
      elph=.true.
      elph_mat=.true.
      elph_simple=.false.
+     elph_epi=.false.
      auxdvscf=trim(fildvscf)
   CASE( 'interpolated' )
      elph=.true.
      elph_mat=.false.
      elph_simple=.false.
+     elph_epi=.false.
   ! YAMBO >
   CASE( 'yambo' )
      elph=.true.
      elph_mat=.false.
      elph_simple=.false.
+     elph_epi=.false.
      elph_yambo=.true.
      nogg=.true.
      auxdvscf=trim(fildvscf)
@@ -397,6 +406,7 @@
      elph=.false.
      elph_mat=.false.
      elph_simple=.false.
+     elph_epi=.false.
      elph_yambo=.false.
      dvscf_yambo=.true.
      nogg=.true.
@@ -424,6 +434,7 @@
      elph=.false.
      elph_mat=.false.
      elph_simple=.false.
+     elph_epi=.false.
   END SELECT
   ! YAMBO >
   IF (.not.elph_yambo) then
Only in qe-6.1/PHonon/PH: phq_readin.f90.orig
diff -ur qe-6.1_original/PHonon/PH/q_points.f90 qe-6.1/PHonon/PH/q_points.f90
--- qe-6.1_original/PHonon/PH/q_points.f90	2017-03-02 22:46:26.000000000 -0800
+++ qe-6.1/PHonon/PH/q_points.f90	2017-04-19 09:02:42.713521000 -0700
@@ -11,7 +11,7 @@
 
   USE kinds, only : dp
   USE io_global,  ONLY :  stdout, ionode, ionode_id
-  USE disp,  ONLY : nq1, nq2, nq3, x_q, nqs, lgamma_iq
+  USE disp,  ONLY : nq1, nq2, nq3, x_q, nqs, lgamma_iq, wq
   USE output, ONLY : fildyn
   USE symm_base, ONLY : nsym, s, time_reversal, t_rev, invs
   USE cell_base, ONLY : at, bg
@@ -25,7 +25,7 @@
   integer :: i, iq, ierr, iudyn = 26
   logical :: exist_gamma, check, skip_equivalence=.FALSE.
   logical, external :: check_q_points_sym
-  real(DP), allocatable :: xq(:,:), wq(:)
+  real(DP), allocatable :: xq(:,:), w_q(:)
 
   INTEGER :: nqmax
   !
@@ -37,20 +37,22 @@
 
   nqmax= nq1 * nq2 * nq3
 
-  allocate (wq(nqmax))
+  allocate (w_q(nqmax))
   allocate (xq(3,nqmax))
   if(lshift_q) then
      call kpoint_grid( nsym, time_reversal, skip_equivalence, s, t_rev, bg, nqmax,&
-     &                  1,1,1, nq1,nq2,nq3, nqs, xq, wq )
+     &                  1,1,1, nq1,nq2,nq3, nqs, xq, w_q )
   else
      call kpoint_grid( nsym, time_reversal, skip_equivalence, s, t_rev, bg, nqmax,&
-     &                  0,0,0, nq1,nq2,nq3, nqs, xq, wq )
+     &                  0,0,0, nq1,nq2,nq3, nqs, xq, w_q )
   end if
+  allocate(wq(nqs))
   allocate(x_q(3,nqs))
   allocate(lgamma_iq(nqs))
+  wq(:)=w_q(1:nqs)
   x_q(:,:)=xq(:,1:nqs)
   deallocate (xq)
-  deallocate (wq)
+  deallocate (w_q)
   !
   ! Check if the Gamma point is one of the points and put
   ! it in the first position (it should already be the first)
Only in qe-6.1/PHonon/PH: q_points.f90.orig
